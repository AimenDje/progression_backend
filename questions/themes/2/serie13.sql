INSERT INTO serie (themeID, serieID, numero, titre, description)
VALUES (2, 13, 6, "Les exceptions", "Réimplémentation de l'utilitaire <em>ping<\em> en python");

    
INSERT INTO question (type, numero, serieID, titre, description, enonce) VALUES (0, 1, 13,'Question 1', 'Question 1', 'Encore une fois, vous tentez de reproduire un outils commun en Python (peut-être dans l\'optique de développer PythonOS). Cette fois, vous vous attaquez à ping. Cette commande permet de tester la connectivité d\'un hôte distant. Vous avez déjà terminé la fonction <code>envoyerICMP</code> qui envoit un paquet ICMP (un paquet de test) à l\'hôte et calcule le temps requis pour recevoir une réponse. Faites maintenant la fonction <code>ping</code> elle-même.');
INSERT INTO question_prog (questionID, reponse, setup, pre_exec, pre_code, in_code, post_code) VALUES ((SELECT max(questionID) FROM question), '"64 octets recus de 8.8.8.8 : temps ecoule=".(2*\$r)." ms"', '$r=rand(10,100);  ', '"\nfrom time import sleep\n\nclass ICMP:\n def __init__(self,n):\n  pass\n\nclass Socket:\n def send_packet(self,x):\n  sleep(".\$r."/1000)\n def receive_packet(self):\n  sleep(".\$r."/1000)\n  \ndef open_socket( x ):\n return Socket()\n \n"', '"\nimport time\n\ndef envoyerICMP( destination ):\n    \\"\\"\\"\n    Envoie un paquet ICMP à un hôte distant et calcule le temps écoulé avant de recevoir la réponse.\n\n    Paramètre :\n    - destination : str, l\'adresse IP d\'un hôte distant.\n\n    Retour : le temps écoulé entre l\'envoi et la réception de la réponse en millisecondes.\n\n    \\"\\"\\"\n    #Instancie le paquet ICMP\n    paquet_envoyé = ICMP( destination )\n\n    #Ouvre un socket vers la destination\n    socket = open_socket( destination )\n\n    #Chronomètre le temps de l\'aller-retour\n    heure_envoi = time.time()\n\n    #Envoi le paquet et attend la réponse\n    socket.send_packet( paquet_envoyé )\n    paquet_reçu = socket.receive_packet()\n\n    #Retourne le temps écoulé en ms.\n    return time.time()-heure_envoi\n\ndef ping( destination ):\n    \\"\\"\\"\n    Teste l\'accessibilité d\'un hôte distant.\n \n    ping envoie un paquet ICMP et affiche le nombre de millisecondes nécessaires pour l\'aller-retour du paquet\n    sous la forme : \n    64 octets reçus de [destination] : temps écoulé=[x] ms\n\n    où destination est l\'adresse IP de l\'hôte distant\n       x est le nombre de millisecondes écoulées (arrondi à la ms près).\n \n    Paramètre :\n    - destination : str, l\'adresse IP d\'un hôte distant.\n \n    \\"\\"\\"\n"', '', '"\n#Ping google.com\nping( \\"8.8.8.8\\" )\n"');
    
INSERT INTO question (type, numero, serieID, titre, description, enonce) VALUES (0, 2, 13,'Question 2', 'Question 2', 'Fantastique! Maintenant ajoutons la possibilité d\'envoyer une série de paquets et de faire des statistiques.');
INSERT INTO question_prog (questionID, reponse, setup, pre_exec, pre_code, in_code, post_code) VALUES ((SELECT max(questionID) FROM question), '"\n64 octets recus de 8.8.8.8 : temps ecoule=".(2*\$r[0])." ms\n64 octets recus de 8.8.8.8 : temps ecoule=".(2*\$r[1])." ms\n64 octets recus de 8.8.8.8 : temps ecoule=".(2*\$r[2])." ms\n64 octets recus de 8.8.8.8 : temps ecoule=".(2*\$r[3])." ms\n64 octets recus de 8.8.8.8 : temps ecoule=".(2*\$r[4])." ms\nrtt min/moy/max = ".strval(min(\$r)*2)."/".strval(round(array_sum(\$r)*2/count(\$r)))."/".strval(max(\$r)*2)."ms"', '$r=array(rand(10,100),rand(10,100),rand(10,100),rand(10,100),rand(10,100));  ', '"\nfrom time import sleep\n\nclass ICMP:\n def __init__(self,n):\n  pass\n\nclass Socket:\n\n no=0\n nbs=[ ".\$r[0].", ".\$r[1].", ".\$r[2].", ".\$r[3].", ".\$r[4]." ]\n def send_packet(self,x):\n  sleep(Socket.nbs[Socket.no]/1000)\n def receive_packet(self):\n  sleep(Socket.nbs[Socket.no]/1000)\n  Socket.no+=1\n  \ndef open_socket( x ):\n return Socket()\n \n"', '"\nimport time\n\ndef envoyerICMP( destination ):\n    \\"\\"\\"\n    Envoie un paquet ICMP à un hôte distant et calcule le temps écoulé avant de recevoir la réponse.\n\n    Paramètre :\n    - destination : str, l\'adresse IP d\'un hôte distant.\n\n    Retour : le temps écoulé entre l\'envoi et la réception de la réponse en millisecondes.\n\n    \\"\\"\\"\n    #Instancie le paquet ICMP\n    paquet_envoyé = ICMP( destination )\n\n    #Ouvre un socket vers la destination\n    socket = open_socket( destination )\n\n    #Chronomètre le temps de l\'aller-retour\n    heure_envoi = time.time()\n\n    #Envoi le paquet et attend la réponse\n    socket.send_packet( paquet_envoyé )\n    paquet_reçu = socket.receive_packet()\n\n    #Retourne le temps écoulé en ms.\n    return time.time()-heure_envoi\n\ndef ping( destination, nb_paquets ):\n    \\"\\"\\"\n    Teste l\'accessibilité d\'un hôte distant.\n \n    ping envoie un ou plusieurs paquets ICMP et affiche le nombre de millisecondes nécessaires pour l\'aller-retour de chaque paquet\n    ainsi que le temps minimal, moyen et maximal sous la forme : \n    64 octets reçus de [destination] : temps écoulé=[x] ms\n\n    rtt min/moy/max = [min]/[moy]/[max] ms\n\n    où destination est l\'adresse IP de l\'hôte distant\n       x est le nombre de millisecondes écoulées (arrondi à la ms près).\n       min est le nombre minimal de millisecondes écoulées (arrondi à la ms près).\n       moy est le nombre moyen de millisecondes écoulées (arrondi à la ms près).\n       max est le nombre maximal de millisecondes écoulées (arrondi à la ms près).\n \n    Paramètre :\n    - destination : str, l\'adresse IP d\'un hôte distant.\n    - nb_paquets : entier, le nombre de paquets ICMP à envoyer.\n \n    \\"\\"\\""', '', '"\n#Ping google.com\nping( \\"8.8.8.8\\", 5 )\n"');
    
INSERT INTO question (type, numero, serieID, titre, description, enonce) VALUES (0, 3, 13,'Question 3', 'Question 3', 'Que faire si on ne reçoit jamais de réponse de l\'hôte? Dans ce cas, une <code>envoyerICMP</code> lance une exception. Comptez le nombre de paquets perdus.');
INSERT INTO question_prog (questionID, reponse, setup, pre_exec, pre_code, in_code, post_code) VALUES ((SELECT max(questionID) FROM question), '"\n64 octets recus de 8.8.8.8 : ".(\$r[0]>70?"perdu.":"temps ecoule=".(2*\$r[0])." ms")."\n64 octets recus de 8.8.8.8 : ".(\$r[1]>70?"perdu.":"temps ecoule=".(2*\$r[1])." ms")."\n64 octets recus de 8.8.8.8 : ".(\$r[2]>70?"perdu.":"temps ecoule=".(2*\$r[2])." ms")."\n64 octets recus de 8.8.8.8 : ".(\$r[3]>70?"perdu.":"temps ecoule=".(2*\$r[3])." ms")."\n64 octets recus de 8.8.8.8 : ".(\$r[4]>70?"perdu.":"temps ecoule=".(2*\$r[4])." ms")."\n5 paquets transmis, ".(5-\$nb_perdus)." recus, ".(\$nb_perdus/5*100)."% perdus\nrtt min/moy/max = ".strval(\$min*2)."/".strval(round(\$somme*2/(count(\$r)-\$nb_perdus)))."/".strval(\$max*2)."ms"', '$nb_perdus=0; while ($nb_perdus==0 or $nb_perdus==count($r)){     $r=array(rand(10,100),rand(10,100),rand(10,100),rand(10,100),rand(10,100));     $min=100;     $max=0;     $somme=0;     $nb_perdus=0;     for ($i=0;$i<count($r);$i++){       if ($r[$i]>70){         $nb_perdus++;       }       else{         $min=min($min,$r[$i]);         $max=max($max,$r[$i]);         $somme+=$r[$i];       }     } }  ', '"\nfrom time import sleep\n\nclass ICMP:\n def __init__(self,n):\n  pass\n\nclass Socket:\n\n no=0\n nbs=[ \$r[0], \$r[1], \$r[2], \$r[3], \$r[4] ]\n def send_packet(self,x):\n  sleep(Socket.nbs[Socket.no]/1000)\n def receive_packet(self):\n  Socket.no+=1\n  if Socket.nbs[Socket.no-1]>70 :\n      raise TimeoutError(\\"Ping timed out after \\"+str(Socket.nbs[Socket.no-1]*2)+\\" ms\\")\n\n  sleep(Socket.nbs[Socket.no-1]/1000)\n  \ndef open_socket( x ):\n return Socket()\n \n"', '"\nimport time\n\ndef envoyerICMP( destination ):\n    \\"\\"\\"\n    Envoie un paquet ICMP à un hôte distant et calcule le temps écoulé avant de recevoir la réponse.\n\n    Paramètre :\n    - destination : str, l\'adresse IP d\'un hôte distant.\n\n    Retour : le temps écoulé entre l\'envoi et la réception de la réponse en millisecondes.\n\n    Exceptions : lance l\'exception TimeoutError si un paquet envoyé n\'est jamais reçu.\n\n    \\"\\"\\"\n    #Instancie le paquet ICMP\n    paquet_envoyé = ICMP( destination )\n\n    #Ouvre un socket vers la destination\n    socket = open_socket( destination )\n\n    #Chronomètre le temps de l\'aller-retour\n    heure_envoi = time.time()\n\n    #Envoi le paquet et attend la réponse\n    socket.send_packet( paquet_envoyé )\n    paquet_reçu = socket.receive_packet()\n\n    #Retourne le temps écoulé en ms.\n    return time.time()-heure_envoi\n\ndef ping( destination, nb_paquets ):\n    \\"\\"\\"\n    Teste l\'accessibilité d\'un hôte distant.\n \n    ping envoie un ou plusieurs paquets ICMP et affiche le nombre de millisecondes nécessaires pour l\'aller-retour de chaque paquet\n    ainsi qu\'un résumé de l\'activité incluant le pourcentage de paquets perdus, le temps minimal, moyen et maximal sous la forme : \n\n    64 octets reçus de [destination] : temps écoulé=[x] ms\n\n    [nb_paquets] paquets transmis, [n] recus, [p]% perdus\n    rtt min/moy/max = [min]/[moy]/[max] ms\n\n    où destination est l\'adresse IP de l\'hôte distant\n       x est le nombre de millisecondes écoulées (arrondi à la ms près).\n       min est le nombre minimal de millisecondes écoulées (arrondi à la ms près).\n       moy est le nombre moyen de millisecondes écoulées (arrondi à la ms près).\n       max est le nombre maximal de millisecondes écoulées (arrondi à la ms près).\n       n est le nombre de paquets reçus.\n       p est le pourcentage de paquets perdus (envoyés mais non reçus).\n \n    Paramètre :\n    - destination : str, l\'adresse IP d\'un hôte distant.\n    - nb_paquets : entier, le nombre de paquets ICMP à envoyer.\n \n    \\"\\"\\""', '', '"\n#Ping google.com\nping( \\"8.8.8.8\\", 5 )\n"');